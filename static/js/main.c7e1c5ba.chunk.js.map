{"version":3,"sources":["algorithms/node.ts","components/Grid/helpers/Options.ts","components/Grid/helpers/generateGrid.ts","algorithms/stack.ts","algorithms/dfs_graph.ts","algorithms/dijkstra_graph.ts","algorithms/queue.ts","algorithms/bfs_graph.ts","algorithms/priorityQueue.ts","algorithms/a_star_graph.ts","components/Tutorial/Tutorial.tsx","components/Grid/Grid.tsx","components/Main.js","App.js","index.js"],"names":["Node","row","column","this","isStart","isEnd","visited","isInShortestPath","hover","distanceFromStart","Infinity","previous","isWall","weight","gCost","hCost","fCost","algorithmOptions","key","text","value","speedOptions","generateGrid","numRows","numColumns","grid","i","j","StackNode","node","next","Stack","first","size","restOfStack","poppedNode","current","DFSgraph","startNode","endNode","gridFrames","position","col","neighbours","positionIsValid","push","visitedRow","visitedColumn","map","neighbour","child","parent","path","unshift","animationFrame","frontier","pop","markVisited","slice","findNeighbours","length","contains","isNeighbourVisited","markParent","reconstructPath","dijkstra_graph","undefined","markNodeAsVisited","frontierContainsNode","newNeighbourDistance","sort","sortFrontierByDistances","filter","n","nodes","targetNode","node1","node2","QueueNode","Queue","front","back","newNode","dNode","restOfQueue","BFSgraph","unvisitedNodes","pathExists","enqueue","dequeue","console","log","PriorityQueue","values","bubbleUp","swap","dequeuedNode","sinkDown","parentIdx","parentNode","lowestFCostChild","getLowestFCostChild","idx","childAIdx","childBIdx","childA","childB","bubbleIdx","getParentIdx","childIdx","Math","floor","idxA","idxB","temp","aStarGraph","deltaX","abs","deltaY","sqrt","hScore","peek","gScore","tentativeGCost","updateCostsInFrontier","Tutorial","React","useState","open","setOpen","modalNumber","setModalNumber","tutorialMessage","className","Modal","onClose","onOpen","trigger","Button","Header","style","fontSize","Content","Actions","color","onClick","PathVisualizer","props","state","currentHoverNode","inProgress","timeBetweenAnimationFrames","algorithm","e","updatedGrid","r","setState","updatedState","hoverNode","c","g","breadthFirstSeach","dijkstra","depthFirstSearch","result","aStarSearch","generateAnimationFrames","animateNodeVisit","animateShortestPath","that","drawVisitedNode","frame","setTimeout","shortestPath","drawShortestPath","markAsShortestPathNode","totalAnimationTime","nodeRow","nodeColumn","newGrid","speedValue","document","addEventListener","handleKeyDown","removeEventListener","Fragment","Dropdown","button","onChange","handleAlgorithmSelection","bind","placeholder","options","disabled","handleAnimationSpeed","handleAllAnimations","resetBoard","cursor","target","arrow","handleClick","onMouseEnter","toggleHover","onMouseLeave","id","Component","Main","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.c7e1c5ba.chunk.js","sourcesContent":["export interface Node {\n    row: number;\n    column: number;\n    isStart: boolean;\n    isEnd: boolean;\n    visited: boolean;\n    isInShortestPath: boolean;\n    hover: boolean;\n    distanceFromStart: number;\n    previous: Node | null;\n    isWall: boolean;\n    weight: number;\n    gCost: number;\n    hCost: number;\n    fCost: number;\n}\n\nexport class Node {\n    constructor(row: number, column: number) {\n        this.row = row;\n        this.column = column;\n        this.isStart = false;\n        this.isEnd = false;\n        this.visited = false;\n        this.isInShortestPath = false;\n        this.hover = false;\n        this.distanceFromStart = Infinity;\n        this.previous = null;\n        this.isWall = false;\n        this.weight = 1\n        this.gCost = Infinity\n        this.hCost = Infinity\n        this.fCost = Infinity\n    }\n}\n\nexport type NodeTuple = [number, number]\n","interface AlgorithmOptions {\n    key: string;\n    text: string;\n    value: string;\n}\ninterface SpeedOptions {\n    key: string;\n    text: string;\n    value: string;\n}\n\nexport const algorithmOptions: AlgorithmOptions[] = [\n    {\n        key: \"Dijkstra\",\n        text: \"Dijkstra\",\n        value: \"Dijkstra\",\n    },\n    {\n        key: \"DFS\",\n        text: \"DFS\",\n        value: \"DFS\",\n    },\n    {\n        key: \"BFS\",\n        text: \"BFS\",\n        value: \"BFS\",\n    },\n    {\n        key: \"Astar\",\n        text: \"Astar\",\n        value: \"Astar\",\n    },\n];\n\n\nexport const speedOptions: SpeedOptions[] = [\n    {\n        key: \"Fast\",\n        text: \"Fast\",\n        value: \"Fast\",\n    },\n    {\n        key: \"Medium\",\n        text: \"Medium\",\n        value: \"Medium\",\n    },\n    {\n        key: \"Slow\",\n        text: \"Slow\",\n        value: \"Slow\",\n    },\n];\n","import { Node } from '../../../algorithms/node'\n\n\nexport function generateGrid(numRows: number, numColumns: number) {\n    let grid: Node[][] = [];\n    for (let i = 1; i <= numRows; i++) {\n        grid[i] = [];\n        for (let j = 1; j <= numColumns; j++) {\n            grid[i][j] = new Node(i, j);\n        }\n    }\n    return grid;\n}","import { Node } from './node'\n\nexport interface StackNode {\n    value: Node,\n    next: StackNode | null\n}\n\nexport interface Stack {\n    first: StackNode | null,\n    size: number\n}\n\nexport class StackNode {\n    constructor(node: Node) {\n        this.value = node\n        this.next = null\n    }\n}\nexport class Stack {\n    constructor() {\n        this.first = null\n        this.size = 0\n    }\n    push(node: Node): Stack {\n        if (this.size === 0) {\n            this.first = new StackNode(node)\n        } else {\n            let restOfStack = this.first\n            this.first = new StackNode(node)\n            this.first.next = restOfStack\n        }\n        this.size++\n        return this\n    }\n    pop(): Node | null {\n        let poppedNode\n        if (this.first === null) {\n            return null\n        } else if (this.size === 1 && this.first !== null) {\n            poppedNode = this.first\n            this.first = null\n        } else {\n            let restOfStack = this.first.next\n            poppedNode = this.first\n            this.first = restOfStack\n        }\n        this.size--\n        return poppedNode.value\n    }\n    contains(node: Node): boolean {\n        if (this.size === 0) {\n            return false\n        } else if (this.size === 1) {\n            if (node.row === this.first?.value.row && node.column === this.first?.value.column) {\n                return true\n            } else {\n                return false\n            }\n        } else if (this.size > 1 && this.first !== null) {\n            let current = this.first\n            while (current.next !== null) {\n                if (current.value.row === node.row && current.value.column === node.column) {\n                    return true\n                }\n                current = current.next\n            }\n            if (current.value.row === node.row && current.value.column === node.column) {\n                return true\n            }\n            return false\n        } else {\n            return false\n        }\n    }\n}","import { Node } from './node'\nimport { Stack } from './stack'\nexport interface DFSgraph {\n    grid: Node[][];\n    gridFrames: Node[][][];\n    startNode: Node;\n    endNode: Node;\n    numRows: number;\n    numColumns: number;\n}\n\nexport class DFSgraph {\n    constructor(grid: Node[][], startNode: Node, endNode: Node, numRows: number, numColumns: number) {\n        this.grid = grid;\n        this.gridFrames = [];\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this.numRows = numRows;\n        this.numColumns = numColumns;\n    }\n    positionIsValid(position: number) {\n        // position is a row or column value for a particular node\n        if (\n            position >= 1 &&\n            position <= this.numRows &&\n            position <= this.numColumns\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    isWall(row: number, col: number) {\n        if (this.grid[row][col].isWall) {\n            return true\n        } else {\n            return false\n        }\n    }\n    findNeighbours(row: number, column: number) {\n        let neighbours: Node[] = [];\n        if (this.positionIsValid(row + 1) && this.positionIsValid(column) && !this.isWall(row + 1, column)) {\n            neighbours.push(this.grid[row + 1][column]);\n        }\n        if (this.positionIsValid(row) && this.positionIsValid(column + 1) && !this.isWall(row, column + 1)) {\n            neighbours.push(this.grid[row][column + 1]);\n        }\n        if (this.positionIsValid(row - 1) && this.positionIsValid(column) && !this.isWall(row - 1, column)) {\n            neighbours.push(this.grid[row - 1][column]);\n        }\n        if (this.positionIsValid(row) && this.positionIsValid(column - 1) && !this.isWall(row, column - 1)) {\n            neighbours.push(this.grid[row][column - 1]);\n        }\n        return neighbours;\n    }\n    markNodeAsVisited(visitedRow: number, visitedColumn: number) {\n        this.grid = this.grid.map((row) =>\n            row.map((node) => {\n                if (node.row === visitedRow && node.column === visitedColumn) {\n                    return {\n                        ...node,\n                        visited: true,\n                    };\n                } else {\n                    return node;\n                }\n            })\n        );\n    }\n    isNeighbourVisited(neighbour: Node): boolean {\n        let isVisited: boolean = this.grid[neighbour.row][neighbour.column].visited;\n        if (isVisited) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    markVisited(visitedRow: number, visitedColumn: number) {\n        this.grid = this.grid.map((row) =>\n            row.map((node) => {\n                if (node.row === visitedRow && node.column === visitedColumn) {\n                    return {\n                        ...node,\n                        visited: true\n                    };\n                } else {\n                    return node;\n                }\n            })\n        );\n    }\n    markParent(child: Node, parent: Node) {\n        child = { ...child, previous: parent }\n        this.grid[child.row][child.column] = child\n    }\n    reconstructPath(): Node[] {\n        let path: Node[] = []\n        // NOTE: we must use the grid here since the 'endNode' prev property does not get updated\n        let current: Node = this.grid[this.endNode.row][this.endNode.column]\n        path.unshift(current)\n        while (current.previous !== null) {\n            current = this.grid[current.previous.row][current.previous.column]\n            path.unshift(current)\n        }\n        return path\n    }\n    depthFirstSearch(): [Node[], Node[][][]] {\n        let animationFrame: Node[][]\n        let frontier = new Stack()\n        let current: Node | null\n\n        // push start node onto stack\n        frontier.push(this.startNode)\n\n        while (frontier.size > 0) {\n            current = frontier.pop()\n            // the stack returns a non-null node\n            if (current !== null) {\n                // if end node reached\n                if (current.isEnd) {\n                    // marks end node as visited in grid \n                    this.markVisited(current.row, current.column)\n                    // create animation frame\n                    animationFrame = this.grid.slice()\n                    this.gridFrames.push(animationFrame)\n                    // break out of loop and reconstruct path to get to end node\n                    break;\n                }\n                // Else, keep pushing neighbours onto stack \n                let neighbours = this.findNeighbours(current.row, current.column)\n\n                for (let i = 0; i < neighbours.length; i++) {\n                    if (!frontier.contains(neighbours[i]) && !this.isNeighbourVisited(neighbours[i])) {\n                        // if neighbour NOT in frontier and is UNVISITED, push neighbour onto stack\n                        frontier.push(neighbours[i])\n                        // mark neighbour's parent with previous pointer to current to help reconstruct path\n                        this.markParent(neighbours[i], current)\n                    }\n                }\n\n                // mark current node as visited in grid\n                this.markVisited(current.row, current.column)\n                animationFrame = this.grid.slice()\n                this.gridFrames.push(animationFrame)\n            }\n        }\n        let path: Node[] = this.reconstructPath()\n        return [path, this.gridFrames]\n    }\n}","import { Node } from \"./node\";\n\nexport interface dijkstra_graph {\n  startNode: Node;\n  endNode: Node;\n  grid: Node[][];\n  numRows: number;\n  numColumns: number;\n  gridFrames: Node[][][];\n}\n\nexport class dijkstra_graph {\n  constructor(\n    grid: Node[][],\n    startNode: Node,\n    endNode: Node,\n    numRows: number,\n    numColumns: number\n  ) {\n    this.startNode = startNode;\n    this.endNode = endNode;\n    this.grid = grid;\n    this.numRows = numRows;\n    this.numColumns = numColumns;\n    this.gridFrames = [];\n  }\n  isWall(row: number, col: number) {\n    if (this.grid[row][col].isWall) {\n      return true\n    } else {\n      return false\n    }\n  }\n  positionIsValid(position: number) {\n    // position is a row or column value for a particular node\n    if (\n      position >= 1 &&\n      position <= this.numRows &&\n      position <= this.numColumns\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  findNeighbours(row: number, column: number) {\n    let neighbours: Node[] = [];\n    if (this.positionIsValid(row + 1) && this.positionIsValid(column) && !this.isWall(row + 1, column)) {\n      neighbours.push(this.grid[row + 1][column]);\n    }\n    if (this.positionIsValid(row) && this.positionIsValid(column + 1) && !this.isWall(row, column + 1)) {\n      neighbours.push(this.grid[row][column + 1]);\n    }\n    if (this.positionIsValid(row - 1) && this.positionIsValid(column) && !this.isWall(row - 1, column)) {\n      neighbours.push(this.grid[row - 1][column]);\n    }\n    if (this.positionIsValid(row) && this.positionIsValid(column - 1) && !this.isWall(row, column - 1)) {\n      neighbours.push(this.grid[row][column - 1]);\n    }\n    return neighbours;\n  }\n  markNodeAsVisited(visitedRow: number, visitedColumn: number) {\n    this.grid = this.grid.map((row) =>\n      row.map((node) => {\n        if (node.row === visitedRow && node.column === visitedColumn) {\n          return {\n            ...node,\n            visited: true,\n          };\n        } else {\n          return node;\n        }\n      })\n    );\n  }\n  isNeighbourVisited(neighbour: Node): boolean {\n    let isVisited: boolean = this.grid[neighbour.row][neighbour.column].visited;\n    if (isVisited) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  markParent(child: Node, parent: Node) {\n    child = { ...child, previous: parent }\n    this.grid[child.row][child.column] = child\n  }\n  reconstructPath(): Node[] {\n    debugger;\n    let path: Node[] = []\n    // NOTE: we must use the grid here since the 'endNode' prev property does not get updated\n    let current: Node = this.grid[this.endNode.row][this.endNode.column]\n    path.unshift(current)\n    while (current.previous !== null) {\n      current = this.grid[current.previous.row][current.previous.column]\n      path.unshift(current)\n    }\n    return path\n  }\n  dijkstra(): [Node[], Node[][][]] {\n    let frontier: Node[] = [] // frontier is a list of nodes to be explored and will be treated as a queue\n\n    this.startNode.distanceFromStart = 0\n    frontier.unshift(this.startNode)\n\n    while (frontier.length !== 0) {\n      let current: Node | undefined = frontier.pop()\n      if (current !== undefined && current.isEnd) {\n        this.markNodeAsVisited(current.row, current.column)\n        this.gridFrames.push(this.grid.slice())\n        break;\n      } else if (current !== undefined) {\n        let neighbours: Node[] = this.findNeighbours(current.row, current.column)\n        for (let i = 0; i < neighbours.length; i++) {\n          // IF NEIGHBOUR is not visited\n          if (!neighbours[i].visited) {\n            // IF NEIGHBOUR not in frontier\n            if (!frontierContainsNode(frontier, neighbours[i])) {\n              // enqueue NEIGHBOUR  \n              frontier.unshift(neighbours[i])\n            }\n            // calculate weight to NEIGHBOUR from start\n            let newNeighbourDistance: number = current.distanceFromStart + neighbours[i].weight\n            if (newNeighbourDistance < neighbours[i].distanceFromStart) {\n              neighbours[i].distanceFromStart = newNeighbourDistance\n              this.markParent(neighbours[i], current)\n            }\n          }\n        }\n        // sort FRONTIER by distanceFromStart\n        frontier = frontier.sort(sortFrontierByDistances)\n        this.markNodeAsVisited(current.row, current.column)\n        this.gridFrames.push(this.grid.slice())\n        // remove current from FRONTIER\n        frontier = frontier.filter(n => {\n          if (n.row === current?.row && n.column === current?.column) {\n            return false\n          } else {\n            return true\n          }\n        })\n      }\n\n    }\n    let path: Node[] = this.reconstructPath()\n\n    return [path, this.gridFrames]\n  }\n}\n\nfunction frontierContainsNode(nodes: Node[], targetNode: Node) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].row === targetNode.row && nodes[i].column === targetNode.column) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction sortFrontierByDistances(node1: Node, node2: Node) {\n  if (node1.distanceFromStart < node2.distanceFromStart) {\n    return 1\n  } else if (node1.distanceFromStart > node2.distanceFromStart) {\n    return -1\n  } else {\n    return 0\n  }\n}\n\nexport default dijkstra_graph;\n","import { Node } from './node'\n\ninterface QueueNode {\n    value: Node,\n    next: QueueNode | null,\n    previous: QueueNode | null\n}\n\nclass QueueNode {\n    constructor(value: Node) {\n        this.value = value\n        this.next = null\n        this.previous = null\n    }\n}\n\nexport interface Queue {\n    front: QueueNode | null,\n    back: QueueNode | null,\n    size: number\n}\n\nexport class Queue {\n    constructor() {\n        // back -> Qn <-> Qn-1 <-> ... <-> Q1 <- front\n        this.front = null\n        this.back = null\n        this.size = 0\n    }\n    enqueue(node: Node): number {\n        let newNode: QueueNode = new QueueNode(node)\n        if (this.size === 0) {\n            this.back = newNode\n            this.front = newNode\n        } else if (this.size > 0 && this.back !== null) {\n            let restOfQueue = this.back\n            restOfQueue.previous = newNode\n            newNode.next = this.front\n            this.back = newNode\n        }\n        this.size++\n        return this.size\n    }\n    dequeue(): Node | null {\n        let dNode: Node | null = null // \"d node\" is the node is the node to be dequeued\n        if (this.size === 0) {\n            return null\n        } else if (this.size === 1 && this.front !== null) {\n            dNode = this.front.value\n            this.front = null\n            this.back = null\n            this.size--\n            return dNode\n        } else if (this.size > 1 && this.front !== null) {\n            dNode = this.front.value\n            let restOfQueue = this.front.previous\n            this.front = restOfQueue\n            this.size--\n            return dNode\n        } else {\n            return null\n        }\n    }\n    contains(node: Node): boolean {\n        if (this.size === 0) {\n            return false\n        } else if (this.size === 1 && this.front !== null) {\n            if (node.row === this.front.value.row && node.column === this.front.value.column) {\n                return true\n            } else {\n                return false\n            }\n        }\n        // back -> Qn <-> Qn-1 <-> ...Q2 <-> Q1 <- front \n        else if (this.size > 1 && this.front !== null) {\n            let current = this.front\n            while (current.previous !== null) {\n                if (current.value.row === node.row && current.value.column === node.column) {\n                    return true\n                }\n                current = current.previous\n            }\n            if (current.value.row === node.row && current.value.column === node.column) {\n                return true\n            }\n            return false\n        } else {\n            return false\n        }\n    }\n}","import { Node } from './node'\nimport { Queue } from './queue'\n\nexport interface BFSgraph {\n    grid: Node[][];\n    gridFrames: Node[][][];\n    startNode: Node;\n    endNode: Node;\n    numRows: number;\n    numColumns: number;\n}\n\nexport class BFSgraph {\n    constructor(grid: Node[][], startNode: Node, endNode: Node, numRows: number, numColumns: number) {\n        this.grid = grid;\n        this.gridFrames = [];\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this.numRows = numRows;\n        this.numColumns = numColumns;\n    }\n    positionIsValid(position: number) {\n        // position is a row or column value for a particular node\n        if (\n            position >= 1 &&\n            position <= this.numRows &&\n            position <= this.numColumns\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    isWall(row: number, col: number) {\n        if (this.grid[row][col].isWall) {\n            return true\n        } else {\n            return false\n        }\n    }\n    findNeighbours(row: number, column: number) {\n        let neighbours: Node[] = [];\n        if (this.positionIsValid(row + 1) && this.positionIsValid(column) && !this.isWall(row + 1, column)) {\n            neighbours.push(this.grid[row + 1][column]);\n        }\n        if (this.positionIsValid(row) && this.positionIsValid(column + 1) && !this.isWall(row, column + 1)) {\n            neighbours.push(this.grid[row][column + 1]);\n        }\n        if (this.positionIsValid(row - 1) && this.positionIsValid(column) && !this.isWall(row - 1, column)) {\n            neighbours.push(this.grid[row - 1][column]);\n        }\n        if (this.positionIsValid(row) && this.positionIsValid(column - 1) && !this.isWall(row, column - 1)) {\n            neighbours.push(this.grid[row][column - 1]);\n        }\n        return neighbours;\n    }\n    markVisited(visitedRow: number, visitedColumn: number) {\n        this.grid = this.grid.map((row) =>\n            row.map((node) => {\n                if (node.row === visitedRow && node.column === visitedColumn) {\n                    return {\n                        ...node,\n                        visited: true\n                    };\n                } else {\n                    return node;\n                }\n            })\n        );\n    }\n    markAsShortestPath(visitedRow: number, visitedColumn: number) {\n        this.grid = this.grid.map((row) =>\n            row.map((node) => {\n                if (node.row === visitedRow && node.column === visitedColumn) {\n                    return {\n                        ...node,\n                        isInShortestPath: true\n                    };\n                } else {\n                    return node;\n                }\n            })\n        );\n    }\n    isNeighbourVisited(neighbour: Node): boolean {\n        let isVisited: boolean = this.grid[neighbour.row][neighbour.column].visited;\n        if (isVisited) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    endNodeUnvisited(unvisitedNodes: Node[]) {\n        for (let i = 0; i < unvisitedNodes.length; i++) {\n            if (\n                unvisitedNodes[i].row === this.endNode.row &&\n                unvisitedNodes[i].column === this.endNode.column\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n    markParent(child: Node, parent: Node) {\n        child = { ...child, previous: parent }\n        this.grid[child.row][child.column] = child\n    }\n    reconstructPath(): Node[] {\n        let path: Node[] = []\n        // NOTE: we must use the grid here since the 'endNode' prev property does not get updated\n        let current: Node = this.grid[this.endNode.row][this.endNode.column]\n        path.unshift(current)\n        while (current.previous !== null) {\n            current = this.grid[current.previous.row][current.previous.column]\n            path.unshift(current)\n        }\n        return path\n    }\n    breadthFirstSeach(): [Node[], Node[][][]] {\n        let animationFrame: Node[][]\n        let frontier = new Queue()\n        let pathExists: boolean = false\n\n        frontier.enqueue(this.startNode)\n        while (frontier.size > 0) {\n            let current = frontier.dequeue()\n            // the queue returns a non-null node\n            if (current !== null) {\n                // if end node reached\n                if (current.isEnd) {\n                    pathExists = true\n                    // marks end node as visited in grid \n                    this.markVisited(current.row, current.column)\n                    // create animation frame\n                    animationFrame = this.grid.slice()\n                    this.gridFrames.push(animationFrame)\n                    // break out of loop and reconstruct path to get to end node\n                    break;\n                }\n                // Else, keep pushing neighbours onto queue \n                let neighbours = this.findNeighbours(current.row, current.column)\n\n                for (let i = 0; i < neighbours.length; i++) {\n                    if (!frontier.contains(neighbours[i]) && !this.isNeighbourVisited(neighbours[i])) {\n                        // if neighbour NOT in frontier and is UNVISITED, enqueue neighbour\n                        frontier.enqueue(neighbours[i])\n                        // mark neighbour's parent with previous pointer to current to help reconstruct path\n                        this.markParent(neighbours[i], current)\n                    }\n                }\n                // mark current node as visited in grid\n                this.markVisited(current.row, current.column)\n                // animation frames created to visualize BFS\n                animationFrame = this.grid.slice()\n                this.gridFrames.push(animationFrame)\n            }\n        }\n        console.log('pathExists value: ', pathExists)\n        let path: Node[] = this.reconstructPath()\n        return [path, this.gridFrames]\n    }\n}","import { Node } from './node'\n\n/*\n    Create a priority queue that will store an array of nodes.\n    The node with a lower 'fCost' will be considered to be of 'higher priority'\n    than a node with higher 'fCost'\n*/\n\nexport interface PriorityQueue {\n    values: Node[]\n    // e.g. this.values = [node1, node2, ..., nodeN]\n}\n\nexport interface ChildNodeAndIndex {\n    idx: number,\n    node: Node\n}\n\nexport class PriorityQueue {\n    constructor() {\n        this.values = []\n    }\n    enqueue(node: Node, fCost: number, gCost: number, hCost: number): void {\n        node = { ...node, fCost: fCost, gCost: gCost, hCost }\n        this.values.push(node)\n        this.bubbleUp()\n    }\n    dequeue(): Node | null {\n        if (this.values.length === 0) {\n            return null\n        }\n        else {\n            // swap first and last elements in priority queue\n            this.swap(0, this.values.length - 1)\n\n            // pop off the last element which has lowest f cost\n            let dequeuedNode = this.values.pop()\n            if (dequeuedNode === undefined) return null\n\n            // call sink the first element in queue down to correct position\n            this.sinkDown()\n\n            return dequeuedNode\n        }\n    }\n    peek(): Node | null {\n        if (this.values.length === 0) return null\n        return this.values[0]\n    }\n    updateCostsInFrontier(neighbour: Node, fCost: number, gCost: number, hCost: number): Node[] {\n        return this.values.map(node => {\n            if (node.row === neighbour.row && node.column === neighbour.column) {\n                return {\n                    ...node,\n                    distanceFromStart: gCost,\n                    gCost: gCost,\n                    hCost: hCost,\n                    fCost: fCost\n                }\n            } else {\n                return node\n            }\n        })\n    }\n    sinkDown(): void {\n        let parentIdx = 0\n        while (true) {\n            let parentNode = this.values[parentIdx]\n            let lowestFCostChild = this.getLowestFCostChild(parentIdx)\n\n            if (lowestFCostChild === null) {\n                return\n            }\n            else if (parentNode.fCost > lowestFCostChild.node.fCost) {\n                this.swap(parentIdx, lowestFCostChild.idx)\n                parentIdx = lowestFCostChild.idx\n            } else {\n                return\n            }\n        }\n    }\n    getLowestFCostChild(parentIdx: number): ChildNodeAndIndex | null {\n        let childAIdx = parentIdx * 2 + 1\n        let childBIdx = parentIdx * 2 + 2\n\n        if (childAIdx >= this.values.length && childBIdx >= this.values.length) {\n            return null\n        } else if (childBIdx >= this.values.length) {\n            return { idx: childAIdx, node: this.values[childAIdx] }\n        } else if (childAIdx >= this.values.length) {\n            return { idx: childBIdx, node: this.values[childBIdx] }\n        } else {\n            let childA = this.values[childAIdx]\n            let childB = this.values[childBIdx]\n\n            if (childA.fCost < childB.fCost) {\n                return { idx: childAIdx, node: childA }\n            }\n            if (childB.fCost < childA.fCost) {\n                return { idx: childBIdx, node: childB }\n            }\n            if (childA.fCost === childB.fCost) {\n                return { idx: childAIdx, node: childA }\n            }\n            return null\n        }\n\n\n    }\n    bubbleUp(): void {\n        let bubbleIdx: number, bubbleNode: Node\n        let parentIdx: number | null, parentNode: Node\n\n        bubbleIdx = this.values.length - 1\n        while (true) {\n            parentIdx = this.getParentIdx(bubbleIdx)\n            if (parentIdx === null || this.values.length === 1) {\n                return\n            } else {\n                parentNode = this.values[parentIdx]\n                bubbleNode = this.values[bubbleIdx]\n                if (bubbleNode.fCost < parentNode.fCost) {\n                    this.swap(bubbleIdx, parentIdx)\n                    bubbleIdx = parentIdx\n                } else {\n                    return\n                }\n            }\n        }\n    }\n    getParentIdx(childIdx: number): number | null {\n        let parentIdx = Math.floor((childIdx - 1) / 2)\n        if (childIdx < 0 || childIdx >= this.values.length) {\n            // invalid child index\n            return null\n        }\n        if (parentIdx < 0) {\n            // invalid parent index \n            return null\n        }\n        return parentIdx\n    }\n    swap(idxA: number, idxB: number): void {\n        // swap elements at idxA and idxB\n        let temp = this.values[idxA]\n        this.values[idxA] = this.values[idxB]\n        this.values[idxB] = temp\n    }\n    contains(node: Node) {\n        for (let i = 0; i < this.values.length; i++) {\n            if (this.values[i].row === node.row && this.values[i].column === node.column) {\n                return true\n            }\n        }\n        return false\n    }\n    length(): number {\n        return this.values.length\n    }\n    print(): void {\n        console.log(this.values)\n    }\n}","import { Node } from \"./node\";\nimport { PriorityQueue } from './priorityQueue'\n\nexport interface aStarGraph {\n    startNode: Node;\n    endNode: Node;\n    grid: Node[][];\n    numRows: number;\n    numColumns: number;\n    gridFrames: Node[][][];\n}\n\nexport class aStarGraph {\n    constructor(\n        grid: Node[][],\n        startNode: Node,\n        endNode: Node,\n        numRows: number,\n        numColumns: number\n    ) {\n        this.startNode = startNode;\n        this.endNode = endNode;\n        this.grid = grid;\n        this.numRows = numRows;\n        this.numColumns = numColumns;\n        this.gridFrames = [];\n    }\n    isWall(row: number, col: number) {\n        if (this.grid[row][col].isWall) {\n            return true\n        } else {\n            return false\n        }\n    }\n    positionIsValid(position: number) {\n        // position is a row or column value for a particular node\n        if (\n            position >= 1 &&\n            position <= this.numRows &&\n            position <= this.numColumns\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    findNeighbours(row: number, column: number) {\n        let neighbours: Node[] = [];\n        if (this.positionIsValid(row + 1) && this.positionIsValid(column) && !this.isWall(row + 1, column)) {\n            neighbours.push(this.grid[row + 1][column]);\n        }\n        if (this.positionIsValid(row) && this.positionIsValid(column + 1) && !this.isWall(row, column + 1)) {\n            neighbours.push(this.grid[row][column + 1]);\n        }\n        if (this.positionIsValid(row - 1) && this.positionIsValid(column) && !this.isWall(row - 1, column)) {\n            neighbours.push(this.grid[row - 1][column]);\n        }\n        if (this.positionIsValid(row) && this.positionIsValid(column - 1) && !this.isWall(row, column - 1)) {\n            neighbours.push(this.grid[row][column - 1]);\n        }\n        return neighbours;\n    }\n    markNodeAsVisited(visitedRow: number, visitedColumn: number) {\n        this.grid = this.grid.map((row) =>\n            row.map((node) => {\n                if (node.row === visitedRow && node.column === visitedColumn) {\n                    return {\n                        ...node,\n                        visited: true,\n                    };\n                } else {\n                    return node;\n                }\n            })\n        );\n    }\n    markParent(child: Node, parent: Node) {\n        child = { ...child, previous: parent }\n        this.grid[child.row][child.column] = child\n    }\n    reconstructPath(): Node[] {\n        let path: Node[] = []\n        // NOTE: we must use the grid here since the 'endNode' prev property does not get updated\n        let current: Node = this.grid[this.endNode.row][this.endNode.column]\n        path.unshift(current)\n        while (current.previous !== null) {\n            current = this.grid[current.previous.row][current.previous.column]\n            path.unshift(current)\n        }\n        return path\n    }\n    hScore(node: Node) {\n        // Returns the straight-line distance from given node to target node\n        // h score is a 'heuristic' or 'best guess' for which paths to explore next\n        const deltaX = Math.abs(this.endNode.column - node.column)\n        const deltaY = Math.abs(this.endNode.row - node.row)\n        return Math.sqrt(deltaX ** 2 + deltaY ** 2)\n    }\n    gScore(current: Node, neighbour: Node) {\n        // Returns a number that represents the currently best known (cheapest) path from start node to current node\n        return current.gCost + neighbour.weight\n    }\n    updateCostsInFrontier(frontier: Node[], neighbour: Node, gCost: number): Node[] {\n        let hCost = this.hScore(neighbour)\n        let fCost = hCost + gCost\n        return frontier.map(node => {\n            if (node.row === neighbour.row && node.column === neighbour.column) {\n                return {\n                    ...node,\n                    distanceFromStart: gCost,\n                    gCost: gCost,\n                    hCost: hCost,\n                    fCost: fCost\n                }\n            } else {\n                return node\n            }\n        })\n    }\n    frontierContains(node: Node, frontier: Node[]) {\n        for (let i = 0; i < frontier.length; i++) {\n            if (frontier[i].row === node.row && frontier[i].column === node.column) {\n                return true\n            }\n        }\n        return false\n    }\n    aStarSearch(): [Node[], Node[][][]] {\n        let frontier: PriorityQueue = new PriorityQueue() // set of all open nodes to be explored\n        let current: Node | null // current node being examined\n        let neighbours: Node[] // neighbouring nodes of current\n\n        // initialize scores for start node\n        let hCost = this.hScore(this.startNode)\n        let gCost = 0\n        let fCost = hCost + gCost\n\n        // enqueue operation requires a node (this.startNode) and an fCost (0)\n        frontier.enqueue(this.startNode, fCost, gCost, hCost)\n\n        while (frontier.length() !== 0) {\n            // peek returns the lowest fCost node in frontier\n            current = frontier.peek()\n            if (current === null) break;\n\n            // dequeue removes the lowest fCost node from frontier\n            frontier.dequeue()\n\n            // mark nodes as visited in this.grid for animating path\n            this.markNodeAsVisited(current.row, current.column)\n            this.gridFrames.push(this.grid.slice())\n\n            if (current.isEnd) break;\n\n            else {\n\n                neighbours = this.findNeighbours(current.row, current.column)\n\n                for (let i = 0; i < neighbours.length; i++) {\n\n                    // if neighbour not in frontier, add neighbour\n                    if (!frontier.contains(neighbours[i]) && !neighbours[i].visited) {\n\n                        // note that these are costs of the 'ith neighbour'\n                        let gCost = this.gScore(current, neighbours[i])\n                        let hCost = this.hScore(neighbours[i])\n                        let fCost = gCost + hCost\n\n                        // update costs of ith neighbour\n                        neighbours[i].gCost = gCost\n                        neighbours[i].hCost = hCost\n                        neighbours[i].fCost = fCost\n\n                        // update frontier\n                        frontier.enqueue(neighbours[i], fCost, gCost, hCost)\n\n                        // mark current as the parent of ith neighbour to allow re-tracing of steps\n                        this.markParent(neighbours[i], current)\n                    }\n\n                    // if neighbour is not yet visited, calculate gScore to neighbour and compare with current gScore\n                    if (!neighbours[i].visited) {\n                        let tentativeGCost = this.gScore(current, neighbours[i])\n                        let hCost = this.hScore(neighbours[i])\n                        let fCost = tentativeGCost + hCost\n\n                        if (tentativeGCost < neighbours[i].gCost) {\n                            // path to current is cheaper so record it\n                            this.markParent(neighbours[i], current)\n\n                            // update f, g, h scores in priority queue\n                            frontier.updateCostsInFrontier(neighbours[i], fCost, tentativeGCost, hCost)\n\n                        }\n                    }\n                }\n            }\n\n        }\n        let path: Node[] = this.reconstructPath()\n        return [path, this.gridFrames]\n    }\n}\n","import React from \"react\";\nimport { Button, Modal } from \"semantic-ui-react\";\n\nfunction Tutorial() {\n  const [open, setOpen] = React.useState(false);\n  const [modalNumber, setModalNumber] = React.useState(1);\n\n  let tutorialMessage = \"Use w to create walls!\";\n\n  switch (modalNumber) {\n    case 1:\n      tutorialMessage =\n        \"Hold down w (lowercase) while hovering the mouse over a grid cell to create walls!\" +\n        \"\\n\" +\n        \"All algorithms will try to find a path around the walls!\";\n      break;\n    case 2:\n      tutorialMessage =\n        \"Hold down W (uppercase) while hovering the mouse over a grid cell to remove walls!\";\n      break;\n    case 3:\n      tutorialMessage =\n        \"Hold down e (lowercase) while hovering the mouse over a grid cell to create weights!\" +\n        \"\\n\" +\n        \"Dijkstra's algorithm and the A-star algorithm will take the weights into account as they try to find the shortest path!\";\n      break;\n    case 4:\n      tutorialMessage = \"Use E (uppercase) to removes weights!\";\n      break;\n    case 5:\n      tutorialMessage = \"That's it!\";\n      break;\n    default:\n      tutorialMessage = \"That's it!\";\n      break;\n  }\n\n  function finishTutorial() {\n    setOpen(false);\n    setModalNumber(1);\n  }\n\n  return (\n    <div className=\"tutorial-container\">\n      <Modal\n        onClose={() => setOpen(false)}\n        onOpen={() => setOpen(true)}\n        open={open}\n        trigger={<Button>Show Tutorial</Button>}\n      >\n        <Modal.Header style={{ fontSize: \"30px\" }}>Pro-tips!</Modal.Header>\n        <Modal.Content>\n          <p style={{ fontSize: \"20px\" }}>{tutorialMessage}</p>\n        </Modal.Content>\n        <Modal.Actions>\n          <Button color=\"black\" onClick={() => setOpen(false)}>\n            Skip Tutorial\n          </Button>\n          {modalNumber >= 5 ? (\n            <Button color=\"black\" onClick={() => finishTutorial()}>\n              Finish!\n            </Button>\n          ) : (\n            <Button\n              color=\"black\"\n              onClick={() => setModalNumber(modalNumber + 1)}\n            >\n              {\" \"}\n              Next Tip!\n            </Button>\n          )}\n        </Modal.Actions>\n      </Modal>\n    </div>\n  );\n}\n\nexport default Tutorial;\n","import React from \"react\";\nimport \"./Grid.css\";\nimport { Dropdown, Button } from \"semantic-ui-react\";\nimport { Node, NodeTuple } from \"../../algorithms/node\";\nimport { algorithmOptions, speedOptions } from \"./helpers/Options\";\nimport { generateGrid } from \"./helpers/generateGrid\";\nimport { DFSgraph } from \"../../algorithms/dfs_graph\";\nimport { dijkstra_graph } from \"../../algorithms/dijkstra_graph\";\nimport { BFSgraph } from \"../../algorithms/bfs_graph\";\nimport { aStarGraph } from \"../../algorithms/a_star_graph\";\nimport Tutorial from \"../Tutorial/Tutorial\";\n\nexport const NUM_OF_ROWS: number = 15;\nexport const NUM_OF_COLUMNS: number = 15;\nexport const WEIGHT: number = 3;\n\ninterface State {\n  grid: Node[][];\n  startNode: Node | null;\n  endNode: Node | null;\n  currentHoverNode: Node | null;\n  inProgress: boolean;\n  algorithm: \"DFS\" | \"BFS\" | \"Dijkstra\" | \"Astar\";\n  timeBetweenAnimationFrames: number;\n}\n\nclass PathVisualizer extends React.Component<any, State> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      grid: generateGrid(NUM_OF_ROWS, NUM_OF_COLUMNS),\n      startNode: null,\n      endNode: null,\n      currentHoverNode: null,\n      inProgress: false,\n      timeBetweenAnimationFrames: 40,\n      algorithm: \"Dijkstra\",\n    };\n  }\n  handleClick(e: React.MouseEvent, row: number, column: number) {\n    let updatedGrid = this.state.grid.slice();\n    // if start node is not yet selected, select it\n    if (this.state.startNode === null) {\n      updatedGrid = updatedGrid.map((r) =>\n        r.map((n) => {\n          if (n.row === row && n.column === column) {\n            return {\n              ...n,\n              distanceFromStart: 0,\n              isStart: true,\n            };\n          } else {\n            return n;\n          }\n        })\n      );\n      let startNode = new Node(row, column);\n      this.setState({\n        startNode: { ...startNode, isStart: true, distanceFromStart: 0 },\n        grid: updatedGrid,\n      });\n    }\n    // if end node is not yet selected, select it\n    else if (this.state.endNode === null) {\n      updatedGrid = updatedGrid.map((r) =>\n        r.map((n) => {\n          if (n.row === row && n.column === column) {\n            return {\n              ...n,\n              isEnd: true,\n            };\n          } else {\n            return n;\n          }\n        })\n      );\n\n      let endNode = new Node(row, column);\n      this.setState({\n        endNode: { ...endNode, isEnd: true },\n        grid: updatedGrid,\n      });\n    }\n  }\n  toggleHover(e: React.MouseEvent, row: number, column: number) {\n    // note: turn off hover effect if animation is in progress\n    // note: do not apply hover effect to start and end node when they have been selected\n    if (!this.state.inProgress) {\n      let updatedState: Node[][] = this.state.grid.slice();\n      let hoverNode: Node = this.state.grid[row][column];\n      updatedState[row][column].hover = !updatedState[row][column].hover;\n      this.setState({ grid: updatedState, currentHoverNode: hoverNode });\n    }\n  }\n  handleKeyDown(e: KeyboardEvent) {\n    if (\n      !this.state.inProgress &&\n      this.state.currentHoverNode !== null &&\n      e.key === \"w\"\n    ) {\n      let updatedGrid: Node[][] = this.state.grid.slice();\n      let r: number = this.state.currentHoverNode.row;\n      let c: number = this.state.currentHoverNode.column;\n      updatedGrid[r][c].isWall = true;\n      this.setState({ grid: updatedGrid });\n    }\n    if (\n      !this.state.inProgress &&\n      this.state.currentHoverNode !== null &&\n      e.key === \"W\"\n    ) {\n      let updatedGrid: Node[][] = this.state.grid.slice();\n      let r: number = this.state.currentHoverNode.row;\n      let c: number = this.state.currentHoverNode.column;\n      updatedGrid[r][c].isWall = false;\n      this.setState({ grid: updatedGrid });\n    }\n    if (\n      !this.state.inProgress &&\n      this.state.currentHoverNode !== null &&\n      e.key === \"e\"\n    ) {\n      let updatedGrid: Node[][] = this.state.grid.slice();\n      let r: number = this.state.currentHoverNode.row;\n      let c: number = this.state.currentHoverNode.column;\n      updatedGrid[r][c].weight = WEIGHT;\n      this.setState({ grid: updatedGrid });\n    }\n\n    if (\n      !this.state.inProgress &&\n      this.state.currentHoverNode !== null &&\n      e.key === \"E\"\n    ) {\n      let updatedGrid: Node[][] = this.state.grid.slice();\n      let r: number = this.state.currentHoverNode.row;\n      let c: number = this.state.currentHoverNode.column;\n      updatedGrid[r][c].weight = 1;\n      this.setState({ grid: updatedGrid });\n    }\n  }\n  generateAnimationFrames() {\n    if (this.state.startNode === null || this.state.endNode === null) {\n      return {\n        path: [],\n        gridFrames: [],\n      };\n    }\n    // by default, a BFS search is performed\n    let g: DFSgraph | BFSgraph | dijkstra_graph | aStarGraph = new BFSgraph(\n      this.state.grid,\n      this.state.startNode,\n      this.state.endNode,\n      NUM_OF_ROWS,\n      NUM_OF_COLUMNS\n    );\n\n    let path: Node[] = g.breadthFirstSeach()[0];\n    let gridFrames: Node[][][] = g.breadthFirstSeach()[1];\n\n    if (this.state.algorithm === \"Dijkstra\") {\n      g = new dijkstra_graph(\n        this.state.grid,\n        this.state.startNode,\n        this.state.endNode,\n        NUM_OF_ROWS,\n        NUM_OF_COLUMNS\n      );\n      path = g.dijkstra()[0];\n      gridFrames = g.dijkstra()[1];\n    } else if (this.state.algorithm === \"DFS\") {\n      g = new DFSgraph(\n        this.state.grid,\n        this.state.startNode,\n        this.state.endNode,\n        NUM_OF_ROWS,\n        NUM_OF_COLUMNS\n      );\n      path = g.depthFirstSearch()[0];\n      gridFrames = g.depthFirstSearch()[1];\n    } else if (this.state.algorithm === \"BFS\") {\n      // do nothing,\n      // since BFS is selected by default\n    } else if (this.state.algorithm === \"Astar\") {\n      g = new aStarGraph(\n        this.state.grid,\n        this.state.startNode,\n        this.state.endNode,\n        NUM_OF_ROWS,\n        NUM_OF_COLUMNS\n      );\n      let result = g.aStarSearch();\n      path = result[0];\n      gridFrames = result[1];\n    }\n    return {\n      path: path,\n      gridFrames: gridFrames,\n    };\n  }\n  handleAllAnimations(e: React.MouseEvent) {\n    // use 'that' to reference the PathVisualizer class from within setTimeout call\n    let that = this;\n\n    // if startNode and endNode are not selected, do not continue\n    if (this.state.startNode === null || this.state.endNode === null) {\n      return;\n    }\n\n    // path represents the path animated in yellow from start to finish\n    // gridFrames reprsents the frame by frame animation for nodes being visited as the algorithm tries to find the end node\n    let path = this.generateAnimationFrames().path;\n    let gridFrames = this.generateAnimationFrames().gridFrames;\n\n    // keep track of when program is inProgress to prevent user from starting another search while a search is happening\n    this.setState({ inProgress: true });\n\n    // create setTimeout calls for animations\n    this.animateNodeVisit(gridFrames, that);\n    this.animateShortestPath(path, gridFrames, that);\n  }\n  animateNodeVisit(gridFrames: Node[][][], that: PathVisualizer) {\n    // FOR each gridFrame make a call to animate nodeVisitedAnimation\n    for (let i = 0; i < gridFrames.length; i++) {\n      let frame: Node[][] = gridFrames[i];\n      drawVisitedNode(frame, i);\n    }\n    function drawVisitedNode(frame: Node[][], i: number) {\n      setTimeout(() => {\n        that.setState({ grid: frame });\n      }, i * that.state.timeBetweenAnimationFrames);\n    }\n  }\n  animateShortestPath(\n    shortestPath: Node[],\n    gridFrames: Node[][][],\n    that: PathVisualizer\n  ) {\n    // FOR each node in shortestPath, make a call to shortestPathAnimation\n    for (let i = 0; i < shortestPath.length; i++) {\n      let node: Node = shortestPath[i];\n      drawShortestPath(node, i);\n    }\n    function drawShortestPath(node: Node, i: number) {\n      setTimeout(() => {\n        that.setState({\n          grid: that.markAsShortestPathNode(node.row, node.column),\n        });\n      }, that.state.timeBetweenAnimationFrames * gridFrames.length + that.state.timeBetweenAnimationFrames * i);\n    }\n\n    // Mark animation as complete when visited and shortest path animations have completed\n    let totalAnimationTime =\n      that.state.timeBetweenAnimationFrames * gridFrames.length +\n      that.state.timeBetweenAnimationFrames * shortestPath.length;\n    setTimeout(() => {\n      this.setState({ inProgress: !this.state.inProgress });\n    }, totalAnimationTime);\n  }\n  markAsShortestPathNode(nodeRow: number, nodeColumn: number) {\n    let updatedGrid = this.state.grid.slice().map((row) =>\n      row.map((node) => {\n        if (node.row === nodeRow && node.column === nodeColumn) {\n          return {\n            ...node,\n            visited: false,\n            isInShortestPath: true,\n          };\n        } else {\n          return node;\n        }\n      })\n    );\n    return updatedGrid;\n  }\n  updateVisitedPropertyOfNode(node: NodeTuple, that: PathVisualizer) {\n    let [nodeRow, nodeColumn]: [number, number] = node;\n    let updatedGrid: Node[][] = that.state.grid.slice();\n    return updatedGrid.map((row) =>\n      row.map((node) => {\n        if (node.row === nodeRow && node.column === nodeColumn) {\n          return {\n            ...node,\n            visited: !node.visited,\n          };\n        } else {\n          return node;\n        }\n      })\n    );\n  }\n  resetBoard(e: React.MouseEvent) {\n    let newGrid: Node[][] = generateGrid(NUM_OF_ROWS, NUM_OF_COLUMNS);\n\n    this.setState({\n      grid: newGrid,\n      startNode: null,\n      endNode: null,\n      inProgress: false,\n    });\n  }\n  handleAnimationSpeed(e: any, { value }: any) {\n    let speedValue: \"Medium\" | \"Fast\" | \"Slow\" = value;\n    if (speedValue === \"Slow\") {\n      this.setState({ timeBetweenAnimationFrames: 400 });\n    } else if (speedValue === \"Medium\") {\n      this.setState({ timeBetweenAnimationFrames: 100 });\n    } else {\n      this.setState({ timeBetweenAnimationFrames: 20 });\n    }\n  }\n  handleAlgorithmSelection(e: any, { value }: any) {\n    this.setState({ algorithm: value });\n  }\n  componentDidMount() {\n    document.addEventListener(\"keypress\", (e: KeyboardEvent) => {\n      this.handleKeyDown(e);\n    });\n  }\n  componentWillUnmount() {\n    document.removeEventListener(\"keypress\", (e: KeyboardEvent) => {\n      this.handleKeyDown(e);\n    });\n  }\n  render() {\n    return (\n      <React.Fragment>\n        <div className=\"app-container\">\n          <div className=\"menu-container\">\n            <div className=\"menu\">\n              <div className=\"title\">Path Finder</div>\n              <div className=\"dropdown-container\">\n                <Dropdown\n                  button\n                  onChange={this.handleAlgorithmSelection.bind(this)}\n                  placeholder=\"Select algorithm\"\n                  options={algorithmOptions}\n                  className=\"algorithms\"\n                  disabled={this.state.inProgress}\n                />\n              </div>\n              <div className=\"dropdown-container\">\n                <Dropdown\n                  onChange={this.handleAnimationSpeed.bind(this)}\n                  button\n                  placeholder=\"Animation Speed\"\n                  options={speedOptions}\n                  className=\"animation-speed\"\n                  disabled={this.state.inProgress}\n                />\n              </div>\n              <Button\n                disabled={\n                  this.state.startNode === null ||\n                  this.state.endNode === null ||\n                  this.state.inProgress\n                }\n                onClick={(e: React.MouseEvent) =>\n                  this.handleAllAnimations.bind(this, e)()\n                }\n              >\n                Start Search\n              </Button>\n              <Button\n                onClick={(e: React.MouseEvent) => {\n                  this.resetBoard.bind(this, e)();\n                }}\n                disabled={this.state.inProgress}\n              >\n                Reset Board\n              </Button>\n            </div>\n          </div>\n          <div className=\"grid-container\">\n            <div\n              className={\"grid\"}\n              style={!this.state.inProgress ? { cursor: \"pointer\" } : {}}\n            >\n              {this.state.grid.map((row) => {\n                return row.map((node) => {\n                  const target = node.isEnd ? (\n                    <i className=\"fa fa-bullseye\"></i>\n                  ) : null;\n                  const arrow = node.isStart ? (\n                    <i className=\"fa fa-arrow-right\"></i>\n                  ) : null;\n\n                  const weight =\n                    node.weight === WEIGHT && node.visited === false ? (\n                      <i className=\"fa fa-balance-scale\"></i>\n                    ) : null;\n\n                  return (\n                    <div\n                      onClick={(e) =>\n                        this.handleClick.bind(this, e, node.row, node.column)()\n                      }\n                      onMouseEnter={(e) =>\n                        this.toggleHover.bind(this, e, node.row, node.column)()\n                      }\n                      onMouseLeave={(e) =>\n                        this.toggleHover.bind(this, e, node.row, node.column)()\n                      }\n                      id={`${node.row}-${node.column}`}\n                      className={`node\n                          ${node.visited ? \"visited-node\" : null}\n                          ${node.hover ? \"hover-node\" : null}\n                          ${node.isStart ? \"start-node\" : null}\n                          ${node.isEnd ? \"end-node\" : null}\n                          ${node.isInShortestPath ? \"shortest-path-node\" : null}\n                          ${node.isWall ? \"wall-node\" : null}\n                          ${node.weight === WEIGHT ? \"weight-node\" : null}\n                    `}\n                    >\n                      {target}\n                      {arrow}\n                      {weight}\n                    </div>\n                  );\n                });\n              })}\n            </div>\n          </div>\n          <Tutorial />\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default PathVisualizer;\n","import React from \"react\";\nimport Grid from \"./Grid/Grid\";\n\nfunction Main() {\n  return (\n    <div>\n      <Grid />\n    </div>\n  );\n}\n\nexport default Main;\n","import React from \"react\";\nimport Main from \"./components/Main\";\n\nfunction App() {\n  return <Main />;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"../node_modules/font-awesome/css/font-awesome.min.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}